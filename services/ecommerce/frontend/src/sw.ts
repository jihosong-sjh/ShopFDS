/**
 * Service Worker
 *
 * PWA를 위한 Service Worker 설정
 * - 오프라인 지원
 * - 푸시 알림 처리
 * - 백그라운드 동기화
 */

import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { NetworkFirst, CacheFirst, StaleWhileRevalidate } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';

declare const self: ServiceWorkerGlobalScope;

// Precache all assets generated by Vite
precacheAndRoute(self.__WB_MANIFEST);

// API 요청 캐싱 - NetworkFirst 전략
// 네트워크를 우선 시도하고, 실패 시 캐시 사용
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new NetworkFirst({
    cacheName: 'api-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24, // 24시간
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// 이미지 캐싱 - CacheFirst 전략
// 캐시를 우선 사용하고, 없으면 네트워크에서 가져옴
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30일
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// 정적 자산 캐싱 - StaleWhileRevalidate 전략
// 캐시를 즉시 반환하고, 백그라운드에서 업데이트
registerRoute(
  ({ request }) =>
    request.destination === 'style' ||
    request.destination === 'script' ||
    request.destination === 'font',
  new StaleWhileRevalidate({
    cacheName: 'static-resources',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 60 * 60 * 24 * 7, // 7일
      }),
    ],
  })
);

// 최근 본 상품 캐싱 (오프라인 지원)
registerRoute(
  ({ url }) => url.pathname.includes('/products/') && url.pathname.match(/\/products\/[^/]+$/),
  new NetworkFirst({
    cacheName: 'product-details-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 10, // 최근 본 상품 10개만 캐싱
        maxAgeSeconds: 60 * 60 * 24, // 24시간
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// 푸시 알림 수신
self.addEventListener('push', (event) => {
  if (!event.data) {
    return;
  }

  const data = event.data.json();
  const options: NotificationOptions = {
    body: data.body || 'ShopFDS 알림',
    icon: '/pwa-192x192.png',
    badge: '/pwa-192x192.png',
    vibrate: [100, 50, 100],
    data: {
      dateOfArrival: Date.now(),
      primaryKey: data.primaryKey || '1',
      url: data.url || '/',
    },
  };

  event.waitUntil(
    self.registration.showNotification(data.title || 'ShopFDS', options)
  );
});

// 푸시 알림 클릭 처리
self.addEventListener('notificationclick', (event) => {
  event.notification.close();

  const urlToOpen = event.notification.data?.url || '/';

  event.waitUntil(
    self.clients.matchAll({ type: 'window', includeUncontrolled: true }).then((clientList) => {
      // 이미 열려있는 탭이 있으면 포커스
      for (const client of clientList) {
        if (client.url === urlToOpen && 'focus' in client) {
          return client.focus();
        }
      }
      // 없으면 새 탭 열기
      if (self.clients.openWindow) {
        return self.clients.openWindow(urlToOpen);
      }
    })
  );
});

// 백그라운드 동기화 (오프라인에서 작성한 리뷰 등)
self.addEventListener('sync', (event) => {
  if (event.tag === 'sync-reviews') {
    event.waitUntil(syncPendingReviews());
  } else if (event.tag === 'sync-wishlist') {
    event.waitUntil(syncPendingWishlist());
  }
});

async function syncPendingReviews() {
  // 오프라인에서 작성한 리뷰를 서버로 전송
  // IndexedDB나 LocalStorage에서 대기 중인 리뷰를 가져와서 전송
  console.log('[SW] Syncing pending reviews...');
  // TODO: 실제 동기화 로직 구현
}

async function syncPendingWishlist() {
  // 오프라인에서 추가한 위시리스트를 서버로 전송
  console.log('[SW] Syncing pending wishlist items...');
  // TODO: 실제 동기화 로직 구현
}

// Service Worker 설치 완료
self.addEventListener('install', (event) => {
  console.log('[SW] Service Worker installing...');
  self.skipWaiting();
});

// Service Worker 활성화
self.addEventListener('activate', (event) => {
  console.log('[SW] Service Worker activating...');
  event.waitUntil(self.clients.claim());
});

export {};
